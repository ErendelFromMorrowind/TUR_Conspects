Руководит разработкой обычно непосредственно Project Manager. Важную роль также играет тимлид;
Управление просиходит из-за того, что сущуствует очень большое количество путей достижения цели. Для этого существует множество методов, облегачающих жизнь;

Самый классический метод -- Каскадная модель разработки программных продуктов, она же -- Waterfall;
  Суть проста. Все этапы жизни продукта выполняются последовательно -- сначала идея, потом проектирование и так далее;
  Новый этап запускается после полного завершения предыдущего;
  Первая сборка происходит тогда, когда всё уже написано;

  Можно увидеть большое количество проблем. Для начала, как минимум, монолитность системы делает тестирование намного более сложным. Также сложно контроллировать процесс извне, ведь видеть результат можно только в моменты завершения;
  Может произойти печаль, если заказчик придёт, посмотрит, и выдаст что-нибудь типа "А я не это имел в виду", после чего придётся переделывать вообще всё. После таких ситуаций возникают грусть на душе и желание работать как-нибудь по-другому;
  А ещё задача может меняться по ходу разработки;
  Кратко, эти проблемы можно обозвать отсутствием гибкости;

  При этом это тяжело в психологическом плане из-за отсутствия ощущения прогресса по ходу работы, что негативно сказывается на качестве выполняемой работы;

  К тому же отсутствует возможность параллельного выполнения этапов, ведь идут они последовательно. Получается, что работает одна команда, а остальные её ждут, а это медленно и невыгодно;

  Ну и, наконец, если мы не успеваем к дедлайну, нам вообще нечего показать, и мы остаёмся у разбитого корыта бессвязного кода;         //такое часто получается в лицейских проектах



Все эти проблемы подтолкнули людей к поиску способов более гибких способов разработки проектов;
Первопроходцем здесь стала эволюционная(она же итерационная) модель разработки программных продуктом;
  Идея в том, что весь процесс разбивается на этапы. После каждого из этапов должен получаться промежуточный результат;
  Результат предоставляется заказчику, который говорит, надо ли что-то менятяь или можно просто двигаться вперёд;

  Разработка ведётся от простого к сложному;
  Мы сначала делаем что-то, что покажет, похож ли на правду нужный результат в упрощённом виде. Каждый этап даёт проверяемый промежуточный результат;

  Есть два варианта разбиения;
    Инкрементальная разработка. При ней пишутся куски в готовом к релизу виде;
    и Спиральная разработка. При ней пишутся упрощённые версии, которые обрастают мясом и качеством;

  В таком варианте разработки у нас есть и гибкость, и возможность висаться в дедлайн путём переноса недоделанного в будущие версии;
  Психология тоже не страдает, ведь результат всегда есть;

  Но у этой модели есть и минусы. Во-первых, она требует сильно большего количества управления, а это сложно;
  К тому же, у нас много промежуточного кода, который не будет использвоаться в финальной версии, а в итоге просто будет выкинут. Это тербует большего количества работы, но далеко не факт, что больше времени;
  Получается намного менее читаемый и качественный код;
  И, наконец, от постоянного изменения задачи страдает документация, а значит, включать людей в проект сложнее;
  Глобально проект зачастую можно описать словом "Бардак";


Обе модели хороши, но для разных областей;
Каскадная используется тогда, когда нужна скорость. Правда, ради скорости придётся собирать ТЗ по частям и сразу начинать его писать, а зачастую полное ТЗ и не пишется;
У нас получается высокое качество кода, в котором обычно нет костылей. Он более надёжный, да и тестировать его легче;

Очень большие проекты почти всегда пишутся каскадным методом, ведь итерационный попросту развалится за всё время разработки;
В итоге получается, что каскадная модель лучше всего подходит к задачам, которым необходима надёжность, но имеются большие дедлайны, в которые не так сложно попасть;


При этом каскад практически не развивается, а итерационная развивается. Она зачастую получает новые версии для более мелких задач;



А в отдалении от этих двух основных моделей идёт разработка ПО на основе ранее созданных компонентов;
Чем больше развивается программирование, тем мельше кода пишется руками. От этого меняется даже жизненный цикл;
1) Постановка задачи;       //Ну ладно, не сразу меняется
2) Анализ компонентов. Просмотр того, что уже написано, и что мы можем использовать. Найдём, скорее всего, то, что делает не совсем нужное, но похожее;
3) Корректировка требований. Заказчику выдаётся ответное предложение: "Мы можем сделать вот такое вот. Вам подходит?"
4) Разработка. Короткий период, пишутся, по сути, только связки между готовыми модулями. Чем-то похоже на конструктор или, скорее, сборку компьютера;
